学习笔记
### 树
树是n(n>=0)个节点的有限集
定义条件：
1.有且仅有一个根节点
2.子树的个数没有限制，但一定互不相交


### 二叉树
1.只有两个儿子节点（左儿子，右儿子）

#### 二叉树遍历(代码背过)
1.前序：根左右
2.中序：左右根
3.后续：左根右
**前中后指根的遍历顺序**

#### 二叉搜索树
二叉搜索树，也称二叉排序树，是指一棵空树或者具有下列性质的二叉树：
1.左子树上的**所有节点**值均小于根节点的值；
2.右子树上的**所有节点**的值均大于根节点的值；
3.以此类推：左右子树也分别为二叉搜索树

**二叉搜索树的中序遍历是升序遍历，因为中序遍历左根右，左<根<右**

##### 二叉搜索树常见操作
1.查询(查询p，p<根，去左子树找，p>根去右子树找)
2.插入新节点(插入P,从根节点遍历，p>根，去右子树找，p<根去左子树找,循环操作找到位置进行插入)
3.删除(删除节点P，p是叶子节点可直接删除，非叶子节点，则找到与p最相近的节点(找出左子树中最大或右子树中最小的值，替换p并删除该值)
时间复杂度都是O(logn)（极端情况是O(n)->变成单链表）

#### 树节点的定义
```java
public class TreeNode{
    public int val;
    public TreeNode left,right;
    public TreeNode(int val){
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
```

### 堆 heap
**定义**：heap可以迅速找到一堆数中最大或者最小值的数据结构
将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫小顶堆或小根堆。常见的堆有二叉堆，斐波那契堆

假设是大顶堆，常见操作（API）
find-max               O(1)
delete-max            O(logn)
insert(create)          O(logn) 或 O(1)

#### 二叉堆(实现相对容易,但时间复杂度较大)
通过完全二叉树来实现（不是二叉搜索树）
二叉堆（假设大顶）满足以下性质：

* 是一棵完全树
* 树中任意节点的值总是>=其子节点的值;
![31501b731425f6e46ab6a451cd74fcb2.png](en-resource://database/4241:1)


#### 二叉堆的实现细节
1.二叉堆一般都通过数组实现
2.假设“第一个元素”在数组中的索引为0的话，则父节点和子节点的关系如下

* 索引为i的左孩子的索引是  (2i+1)；
* 索引为i的右孩子的索引是  (2i+2)；
* 索引为i的父节点的索引是  floor((i-1)/2);


#### insert 插入操作(O(log2n))

1.新元素一律先插入到堆的尾部
2.依次向上调整整个堆的结构（一直到根即可 HeapifyUp）

![9fc3c4caaa4569f9f07ceebacf48e29f.png](en-resource://database/4243:1)
![1d0afd9f299f1e9cab1eb84b416a5735.png](en-resource://database/4245:1)
![f6d5bb88189e722bfb070df25a97e478.png](en-resource://database/4247:1)

#### delete max 删除堆顶操作
1.将堆尾元素替换到顶部（即堆顶被替代删除掉）
2.依次从根部向下调整整个堆的结构（一直到堆尾即可HeapifyDown）

**注意：二叉堆（binary heap）是堆（优先队列prio_queue）的一种常见且简单的实现；但并不是最优的实现。**

### 图

* Graph(V,E)
* V-vertex:点
    度：入读和出度（角度，1个点有多少个边）
    点与点之间：连同与否
* E-edge:边
    有向和无向
    权重（边长）

 ### 树和图的差别
 树没有环，树永远都不会走回去
 图有环
 
 **链表（linked lis）是特殊化的tree，tree是特殊化的graph**